initSidebarItems({"constant":[["rf24_crclength_e_RF24_CRC_16",""],["rf24_crclength_e_RF24_CRC_8",""],["rf24_crclength_e_RF24_CRC_DISABLED",""],["rf24_datarate_e_RF24_1MBPS",""],["rf24_datarate_e_RF24_250KBPS",""],["rf24_datarate_e_RF24_2MBPS",""]],"fn":[["RF24_RF24","Arduino Constructor"],["RF24_RF241","Optional Linux Constructor"],["RF24_available","Check whether there are bytes available to be read @code if(radio.available()){   radio.read(&data,sizeof(data)); } @endcode @return True if there is a payload available, false if none is"],["RF24_available1","Test whether there are bytes available to be read in the FIFO buffers."],["RF24_begin","Begin operation of the chip"],["RF24_closeReadingPipe","Close a pipe after it has been previously opened. Can be safely called without having previously opened a pipe. @param pipe Which pipe # to close, 0-5."],["RF24_disableCRC","Disable CRC validation"],["RF24_disableDynamicPayloads","Disable dynamically-sized payloads"],["RF24_enableAckPayload","Enable custom payloads on the acknowledge packets"],["RF24_enableDynamicAck","Enable dynamic ACKs (single write multicast or unicast) for chosen messages"],["RF24_enableDynamicPayloads","Enable dynamically-sized payloads"],["RF24_flush_rx","Empty the receive buffer"],["RF24_flush_tx","Empty the transmit buffer. This is generally not required in standard operation. May be required in specific cases after stopListening() , if operating at 250KBPS data rate."],["RF24_getCRCLength","Get the CRC length CRC checking cannot be disabled if auto-ack is enabled @return RF24_CRC_DISABLED if disabled or RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit"],["RF24_getChannel","Get RF communication channel"],["RF24_getDataRate","Fetches the transmission data rate"],["RF24_getDynamicPayloadSize","Get Dynamic Payload Size"],["RF24_getPALevel","Fetches the current PA level."],["RF24_getPayloadSize","Get Static Payload Size"],["RF24_isAckPayloadAvailable","Determine if an ack payload was received in the most recent call to write(). The regular available() can also be used."],["RF24_isChipConnected","Checks if the chip is connected to the SPI bus"],["RF24_isPVariant","Determine whether the hardware is an nRF24L01+ or not."],["RF24_maskIRQ","The radio will generate interrupt signals when a transmission is complete, a transmission fails, or a payload is received. This allows users to mask those interrupts to prevent them from generating a signal on the interrupt pin. Interrupts are enabled on the radio chip by default."],["RF24_openReadingPipe","Open a pipe for reading"],["RF24_openReadingPipe1","Open a pipe for reading @note For compatibility with old code only, see new function"],["RF24_openWritingPipe","New: Open a pipe for writing via byte array. Old addressing format retained  for compatibility."],["RF24_openWritingPipe1","Open a pipe for writing @note For compatibility with old code only, see new function"],["RF24_powerDown","Enter low-power mode"],["RF24_powerUp","Leave low-power mode - required for normal radio operation after calling powerDown()"],["RF24_printDetails","Print a giant block of debugging information to stdout"],["RF24_reUseTX","This function is mainly used internally to take advantage of the auto payload re-use functionality of the chip, but can be beneficial to users as well."],["RF24_read","Read the available payload"],["RF24_rxFifoFull","Check if the radio needs to be read. Can be used to prevent data loss @return True if all three 32-byte radio buffers are full"],["RF24_setAddressWidth","Set the address width from 3 to 5 bytes (24, 32 or 40 bit)"],["RF24_setAutoAck","Enable or disable auto-acknowlede packets"],["RF24_setAutoAck1","Enable or disable auto-acknowlede packets on a per pipeline basis."],["RF24_setCRCLength","Set the CRC length CRC checking cannot be disabled if auto-ack is enabled @param length RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit"],["RF24_setChannel","Set RF communication channel"],["RF24_setDataRate","Set the transmission data rate"],["RF24_setPALevel","Set Power Amplifier (PA) level to one of four levels: RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH and RF24_PA_MAX"],["RF24_setPayloadSize","Set Static Payload Size"],["RF24_setRetries","Set the number and delay of retries upon failed submit"],["RF24_startFastWrite","Non-blocking write to the open writing pipe used for buffered writes"],["RF24_startListening","Start listening on the pipes opened for reading."],["RF24_startWrite","Non-blocking write to the open writing pipe"],["RF24_stopListening","Stop listening for incoming messages, and switch to transmit mode."],["RF24_testCarrier","Test whether there was a carrier on the line for the previous listening period."],["RF24_testRPD","Test whether a signal (carrier or otherwise) greater than or equal to -64dBm is present on the channel. Valid only on nRF24L01P (+) hardware. On nRF24L01, use testCarrier()."],["RF24_txStandBy","This function should be called as soon as transmission is finished to drop the radio back to STANDBY-I mode. If not issued, the radio will remain in STANDBY-II mode which, per the data sheet, is not a recommended operating mode."],["RF24_txStandBy1","This function allows extended blocking and auto-retries per a user defined timeout @code Fully Blocking Example:"],["RF24_whatHappened","Call this when you get an interrupt to find out why"],["RF24_write","Be sure to call openWritingPipe() first to set the destination of where to write to."],["RF24_write1","Write for single NOACK writes. Optionally disables acknowledgements/autoretries for a single write."],["RF24_writeAckPayload","Write an ack payload for the specified pipe"],["RF24_writeBlocking","This function extends the auto-retry mechanism to any specified duration. It will not block until the 3 FIFO buffers are filled with data. If so the library will auto retry until a new payload is written or the user specified timeout period is reached. @warning It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing txStandBy() or ensure appropriate time between transmissions."],["RF24_writeFast","This will not block until the 3 FIFO buffers are filled with data. Once the FIFOs are full, writeFast will simply wait for success or timeout, and return 1 or 0 respectively. From a user perspective, just keep trying to send the same data. The library will keep auto retrying the current payload using the built in functionality. @warning It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO to clear by issuing txStandBy() or ensure appropriate time between transmissions."],["RF24_writeFast1","WriteFast for single NOACK writes. Disables acknowledgements/autoretries for a single write."],["SPI_SPI",""],["SPI_SPI_destructor",""],["SPI_begin",""],["SPI_beginTransaction",""],["SPI_chipSelect",""],["SPI_end",""],["SPI_endTransaction",""],["SPI_setBitOrder",""],["SPI_setClockDivider",""],["SPI_setDataMode",""]],"struct":[["RF24","Driver for nRF24L01(+) 2.4GHz Wireless Transceiver"],["RF24__bindgen_vtable",""],["SPI",""],["SPISettings",""],["SPI__bindgen_vtable",""]],"type":[["rf24_crclength_e","CRC Length.  How big (if any) of a CRC is included."],["rf24_datarate_e","Data rate.  How fast data moves through the air."]]});