/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct SPISettings {
        pub clck: u32,
        pub border: u8,
        pub dmode: u8,
    }
    #[test]
    fn bindgen_test_layout_SPISettings() {
        assert_eq!(
            ::std::mem::size_of::<SPISettings>(),
            8usize,
            concat!("Size of: ", stringify!(SPISettings))
        );
        assert_eq!(
            ::std::mem::align_of::<SPISettings>(),
            4usize,
            concat!("Alignment of ", stringify!(SPISettings))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SPISettings>())).clck as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(SPISettings),
                "::",
                stringify!(clck)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SPISettings>())).border as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(SPISettings),
                "::",
                stringify!(border)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<SPISettings>())).dmode as *const _ as usize },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(SPISettings),
                "::",
                stringify!(dmode)
            )
        );
    }
    #[repr(C)]
    pub struct SPI__bindgen_vtable(::std::os::raw::c_void);
    #[repr(C)]
    #[derive(Debug)]
    pub struct SPI {
        pub vtable_: *const SPI__bindgen_vtable,
    }
    #[test]
    fn bindgen_test_layout_SPI() {
        assert_eq!(
            ::std::mem::size_of::<SPI>(),
            8usize,
            concat!("Size of: ", stringify!(SPI))
        );
        assert_eq!(
            ::std::mem::align_of::<SPI>(),
            8usize,
            concat!("Alignment of ", stringify!(SPI))
        );
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPI5beginEi"]
        pub fn SPI_begin(busNo: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPI3endEv"]
        pub fn SPI_end();
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPI11setBitOrderEh"]
        pub fn SPI_setBitOrder(bit_order: u8);
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPI11setDataModeEh"]
        pub fn SPI_setDataMode(data_mode: u8);
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPI15setClockDividerEt"]
        pub fn SPI_setClockDivider(spi_speed: u16);
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPI10chipSelectEi"]
        pub fn SPI_chipSelect(csn_pin: ::std::os::raw::c_int);
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPI16beginTransactionE11SPISettings"]
        pub fn SPI_beginTransaction(settings: root::SPISettings);
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPI14endTransactionEv"]
        pub fn SPI_endTransaction();
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPIC1Ev"]
        pub fn SPI_SPI(this: *mut root::SPI);
    }
    impl SPI {
        #[inline]
        pub unsafe fn begin(busNo: ::std::os::raw::c_int) {
            SPI_begin(busNo)
        }
        #[inline]
        pub unsafe fn end() {
            SPI_end()
        }
        #[inline]
        pub unsafe fn setBitOrder(bit_order: u8) {
            SPI_setBitOrder(bit_order)
        }
        #[inline]
        pub unsafe fn setDataMode(data_mode: u8) {
            SPI_setDataMode(data_mode)
        }
        #[inline]
        pub unsafe fn setClockDivider(spi_speed: u16) {
            SPI_setClockDivider(spi_speed)
        }
        #[inline]
        pub unsafe fn chipSelect(csn_pin: ::std::os::raw::c_int) {
            SPI_chipSelect(csn_pin)
        }
        #[inline]
        pub unsafe fn beginTransaction(settings: root::SPISettings) {
            SPI_beginTransaction(settings)
        }
        #[inline]
        pub unsafe fn endTransaction() {
            SPI_endTransaction()
        }
        #[inline]
        pub unsafe fn new() -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            SPI_SPI(&mut __bindgen_tmp);
            __bindgen_tmp
        }
    }
    extern "C" {
        #[link_name = "\u{1}__ZN3SPID1Ev"]
        pub fn SPI_SPI_destructor(this: *mut root::SPI);
    }
    pub const rf24_datarate_e_RF24_1MBPS: root::rf24_datarate_e = 0;
    pub const rf24_datarate_e_RF24_2MBPS: root::rf24_datarate_e = 1;
    pub const rf24_datarate_e_RF24_250KBPS: root::rf24_datarate_e = 2;
    #[doc = " Data rate.  How fast data moves through the air."]
    #[doc = ""]
    #[doc = " For use with setDataRate()"]
    pub type rf24_datarate_e = u32;
    pub const rf24_crclength_e_RF24_CRC_DISABLED: root::rf24_crclength_e = 0;
    pub const rf24_crclength_e_RF24_CRC_8: root::rf24_crclength_e = 1;
    pub const rf24_crclength_e_RF24_CRC_16: root::rf24_crclength_e = 2;
    #[doc = " CRC Length.  How big (if any) of a CRC is included."]
    #[doc = ""]
    #[doc = " For use with setCRCLength()"]
    pub type rf24_crclength_e = u32;
    #[repr(C)]
    pub struct RF24__bindgen_vtable(::std::os::raw::c_void);
    #[doc = " Driver for nRF24L01(+) 2.4GHz Wireless Transceiver"]
    #[repr(C)]
    pub struct RF24 {
        pub vtable_: *const RF24__bindgen_vtable,
        pub spi: root::SPI,
        #[doc = "< \"Chip Enable\" pin, activates the RX or TX role"]
        pub ce_pin: u16,
        #[doc = "< SPI Chip select"]
        pub csn_pin: u16,
        #[doc = "< SPI Bus Speed"]
        pub spi_speed: u16,
        pub spi_rxbuff: [u8; 33usize],
        pub spi_txbuff: [u8; 33usize],
        pub p_variant: bool,
        #[doc = "< Fixed size of payloads"]
        pub payload_size: u8,
        #[doc = "< Whether dynamic payloads are enabled."]
        pub dynamic_payloads_enabled: bool,
        #[doc = "< Last address set on pipe 0 for reading."]
        pub pipe0_reading_address: [u8; 5usize],
        #[doc = "< The address width to use - 3,4 or 5 bytes."]
        pub addr_width: u8,
        pub failureDetected: bool,
        #[doc = " The driver will delay for this duration when stopListening() is called"]
        #[doc = ""]
        #[doc = " When responding to payloads, faster devices like ARM(RPi) are much faster than Arduino:"]
        #[doc = " 1. Arduino sends data to RPi, switches to RX mode"]
        #[doc = " 2. The RPi receives the data, switches to TX mode and sends before the Arduino radio is in RX mode"]
        #[doc = " 3. If AutoACK is disabled, this can be set as low as 0. If AA/ESB enabled, set to 100uS minimum on RPi"]
        #[doc = ""]
        #[doc = " @warning If set to 0, ensure 130uS delay after stopListening() and before any sends"]
        pub txDelay: u32,
        #[doc = " On all devices but Linux and ATTiny, a small delay is added to the CSN toggling function"]
        #[doc = ""]
        #[doc = " This is intended to minimise the speed of SPI polling due to radio commands"]
        #[doc = ""]
        #[doc = " If using interrupts or timed requests, this can be set to 0 Default:5"]
        pub csDelay: u32,
    }
    #[test]
    fn bindgen_test_layout_RF24() {
        assert_eq!(
            ::std::mem::size_of::<RF24>(),
            112usize,
            concat!("Size of: ", stringify!(RF24))
        );
        assert_eq!(
            ::std::mem::align_of::<RF24>(),
            8usize,
            concat!("Alignment of ", stringify!(RF24))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).spi as *const _ as usize },
            8usize,
            concat!("Offset of field: ", stringify!(RF24), "::", stringify!(spi))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).ce_pin as *const _ as usize },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(ce_pin)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).csn_pin as *const _ as usize },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(csn_pin)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).spi_speed as *const _ as usize },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(spi_speed)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).spi_rxbuff as *const _ as usize },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(spi_rxbuff)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).spi_txbuff as *const _ as usize },
            55usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(spi_txbuff)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).p_variant as *const _ as usize },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(p_variant)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).payload_size as *const _ as usize },
            89usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(payload_size)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<RF24>())).dynamic_payloads_enabled as *const _ as usize
            },
            90usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(dynamic_payloads_enabled)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).pipe0_reading_address as *const _ as usize },
            91usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(pipe0_reading_address)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).addr_width as *const _ as usize },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(addr_width)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).failureDetected as *const _ as usize },
            97usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(failureDetected)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).txDelay as *const _ as usize },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(txDelay)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<RF24>())).csDelay as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(RF24),
                "::",
                stringify!(csDelay)
            )
        );
    }
    extern "C" {
        #[doc = " Begin operation of the chip"]
        #[doc = ""]
        #[doc = " Call this in setup(), before calling any other methods."]
        #[doc = " @code radio.begin() @endcode"]
        #[link_name = "\u{1}__ZN4RF245beginEv"]
        pub fn RF24_begin(this: *mut root::RF24) -> bool;
    }
    extern "C" {
        #[doc = " Checks if the chip is connected to the SPI bus"]
        #[link_name = "\u{1}__ZN4RF2415isChipConnectedEv"]
        pub fn RF24_isChipConnected(this: *mut root::RF24) -> bool;
    }
    extern "C" {
        #[doc = " Start listening on the pipes opened for reading."]
        #[doc = ""]
        #[doc = " 1. Be sure to call openReadingPipe() first."]
        #[doc = " 2. Do not call write() while in this mode, without first calling stopListening()."]
        #[doc = " 3. Call available() to check for incoming traffic, and read() to get it."]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " Open reading pipe 1 using address CCCECCCECC"]
        #[doc = ""]
        #[doc = " byte address[] = { 0xCC,0xCE,0xCC,0xCE,0xCC };"]
        #[doc = " radio.openReadingPipe(1,address);"]
        #[doc = " radio.startListening();"]
        #[doc = " @endcode"]
        #[link_name = "\u{1}__ZN4RF2414startListeningEv"]
        pub fn RF24_startListening(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Stop listening for incoming messages, and switch to transmit mode."]
        #[doc = ""]
        #[doc = " Do this before calling write()."]
        #[doc = " @code"]
        #[doc = " radio.stopListening();"]
        #[doc = " radio.write(&data,sizeof(data));"]
        #[doc = " @endcode"]
        #[link_name = "\u{1}__ZN4RF2413stopListeningEv"]
        pub fn RF24_stopListening(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Check whether there are bytes available to be read"]
        #[doc = " @code"]
        #[doc = " if(radio.available()){"]
        #[doc = "   radio.read(&data,sizeof(data));"]
        #[doc = " }"]
        #[doc = " @endcode"]
        #[doc = " @return True if there is a payload available, false if none is"]
        #[link_name = "\u{1}__ZN4RF249availableEv"]
        pub fn RF24_available(this: *mut root::RF24) -> bool;
    }
    extern "C" {
        #[doc = " Read the available payload"]
        #[doc = ""]
        #[doc = " The size of data read is the fixed payload size, see getPayloadSize()"]
        #[doc = ""]
        #[doc = " @note I specifically chose 'void*' as a data type to make it easier"]
        #[doc = " for beginners to use.  No casting needed."]
        #[doc = ""]
        #[doc = " @note No longer boolean. Use available to determine if packets are"]
        #[doc = " available. Interrupt flags are now cleared during reads instead of"]
        #[doc = " when calling available()."]
        #[doc = ""]
        #[doc = " @param buf Pointer to a buffer where the data should be written"]
        #[doc = " @param len Maximum number of bytes to read into the buffer"]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " if(radio.available()){"]
        #[doc = "   radio.read(&data,sizeof(data));"]
        #[doc = " }"]
        #[doc = " @endcode"]
        #[doc = " @return No return value. Use available()."]
        #[link_name = "\u{1}__ZN4RF244readEPvh"]
        pub fn RF24_read(this: *mut root::RF24, buf: *mut ::std::os::raw::c_void, len: u8);
    }
    extern "C" {
        #[doc = " Be sure to call openWritingPipe() first to set the destination"]
        #[doc = " of where to write to."]
        #[doc = ""]
        #[doc = " This blocks until the message is successfully acknowledged by"]
        #[doc = " the receiver or the timeout/retransmit maxima are reached.  In"]
        #[doc = " the current configuration, the max delay here is 60-70ms."]
        #[doc = ""]
        #[doc = " The maximum size of data written is the fixed payload size, see"]
        #[doc = " getPayloadSize().  However, you can write less, and the remainder"]
        #[doc = " will just be filled with zeroes."]
        #[doc = ""]
        #[doc = " TX/RX/RT interrupt flags will be cleared every time write is called"]
        #[doc = ""]
        #[doc = " @param buf Pointer to the data to be sent"]
        #[doc = " @param len Number of bytes to be sent"]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " radio.stopListening();"]
        #[doc = " radio.write(&data,sizeof(data));"]
        #[doc = " @endcode"]
        #[doc = " @return True if the payload was delivered successfully and an ACK was received, or upon successfull transmission if auto-ack is disabled."]
        #[link_name = "\u{1}__ZN4RF245writeEPKvh"]
        pub fn RF24_write(
            this: *mut root::RF24,
            buf: *const ::std::os::raw::c_void,
            len: u8,
        ) -> bool;
    }
    extern "C" {
        #[doc = " New: Open a pipe for writing via byte array. Old addressing format retained"]
        #[doc = " for compatibility."]
        #[doc = ""]
        #[doc = " Only one writing pipe can be open at once, but you can change the address"]
        #[doc = " you'll write to. Call stopListening() first."]
        #[doc = ""]
        #[doc = " Addresses are assigned via a byte array, default is 5 byte address length"]
        #[doc = "s   *"]
        #[doc = " @code"]
        #[doc = "   uint8_t addresses[][6] = {\"1Node\",\"2Node\"};"]
        #[doc = "   radio.openWritingPipe(addresses[0]);"]
        #[doc = " @endcode"]
        #[doc = " @code"]
        #[doc = "  uint8_t address[] = { 0xCC,0xCE,0xCC,0xCE,0xCC };"]
        #[doc = "  radio.openWritingPipe(address);"]
        #[doc = "  address[0] = 0x33;"]
        #[doc = "  radio.openReadingPipe(1,address);"]
        #[doc = " @endcode"]
        #[doc = " @see setAddressWidth"]
        #[doc = ""]
        #[doc = " @param address The address of the pipe to open. Coordinate these pipe"]
        #[doc = " addresses amongst nodes on the network."]
        #[link_name = "\u{1}__ZN4RF2415openWritingPipeEPKh"]
        pub fn RF24_openWritingPipe(this: *mut root::RF24, address: *const u8);
    }
    extern "C" {
        #[doc = " Open a pipe for reading"]
        #[doc = ""]
        #[doc = " Up to 6 pipes can be open for reading at once.  Open all the required"]
        #[doc = " reading pipes, and then call startListening()."]
        #[doc = ""]
        #[doc = " @see openWritingPipe"]
        #[doc = " @see setAddressWidth"]
        #[doc = ""]
        #[doc = " @note Pipes 0 and 1 will store a full 5-byte address. Pipes 2-5 will technically"]
        #[doc = " only store a single byte, borrowing up to 4 additional bytes from pipe #1 per the"]
        #[doc = " assigned address width."]
        #[doc = " @warning Pipes 1-5 should share the same address, except the first byte."]
        #[doc = " Only the first byte in the array should be unique, e.g."]
        #[doc = " @code"]
        #[doc = "   uint8_t addresses[][6] = {\"1Node\",\"2Node\"};"]
        #[doc = "   openReadingPipe(1,addresses[0]);"]
        #[doc = "   openReadingPipe(2,addresses[1]);"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @warning Pipe 0 is also used by the writing pipe.  So if you open"]
        #[doc = " pipe 0 for reading, and then startListening(), it will overwrite the"]
        #[doc = " writing pipe.  Ergo, do an openWritingPipe() again before write()."]
        #[doc = ""]
        #[doc = " @param number Which pipe# to open, 0-5."]
        #[doc = " @param address The 24, 32 or 40 bit address of the pipe to open."]
        #[link_name = "\u{1}__ZN4RF2415openReadingPipeEhPKh"]
        pub fn RF24_openReadingPipe(this: *mut root::RF24, number: u8, address: *const u8);
    }
    extern "C" {
        #[doc = " Print a giant block of debugging information to stdout"]
        #[doc = ""]
        #[doc = " @warning Does nothing if stdout is not defined.  See fdevopen in stdio.h"]
        #[doc = " The printf.h file is included with the library for Arduino."]
        #[doc = " @code"]
        #[doc = " #include <printf.h>"]
        #[doc = " setup(){"]
        #[doc = "  Serial.begin(115200);"]
        #[doc = "  printf_begin();"]
        #[doc = "  ..."]
        #[doc = " }"]
        #[doc = " @endcode"]
        #[link_name = "\u{1}__ZN4RF2412printDetailsEv"]
        pub fn RF24_printDetails(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Test whether there are bytes available to be read in the"]
        #[doc = " FIFO buffers."]
        #[doc = ""]
        #[doc = " @param[out] pipe_num Which pipe has the payload available"]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " uint8_t pipeNum;"]
        #[doc = " if(radio.available(&pipeNum)){"]
        #[doc = "   radio.read(&data,sizeof(data));"]
        #[doc = "   Serial.print(\"Got data on pipe\");"]
        #[doc = "   Serial.println(pipeNum);"]
        #[doc = " }"]
        #[doc = " @endcode"]
        #[doc = " @return True if there is a payload available, false if none is"]
        #[link_name = "\u{1}__ZN4RF249availableEPh"]
        pub fn RF24_available1(this: *mut root::RF24, pipe_num: *mut u8) -> bool;
    }
    extern "C" {
        #[doc = " Check if the radio needs to be read. Can be used to prevent data loss"]
        #[doc = " @return True if all three 32-byte radio buffers are full"]
        #[link_name = "\u{1}__ZN4RF2410rxFifoFullEv"]
        pub fn RF24_rxFifoFull(this: *mut root::RF24) -> bool;
    }
    extern "C" {
        #[doc = " Enter low-power mode"]
        #[doc = ""]
        #[doc = " To return to normal power mode, call powerUp()."]
        #[doc = ""]
        #[doc = " @note After calling startListening(), a basic radio will consume about 13.5mA"]
        #[doc = " at max PA level."]
        #[doc = " During active transmission, the radio will consume about 11.5mA, but this will"]
        #[doc = " be reduced to 26uA (.026mA) between sending."]
        #[doc = " In full powerDown mode, the radio will consume approximately 900nA (.0009mA)"]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " radio.powerDown();"]
        #[doc = " avr_enter_sleep_mode(); // Custom function to sleep the device"]
        #[doc = " radio.powerUp();"]
        #[doc = " @endcode"]
        #[link_name = "\u{1}__ZN4RF249powerDownEv"]
        pub fn RF24_powerDown(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Leave low-power mode - required for normal radio operation after calling powerDown()"]
        #[doc = ""]
        #[doc = " To return to low power mode, call powerDown()."]
        #[doc = " @note This will take up to 5ms for maximum compatibility"]
        #[link_name = "\u{1}__ZN4RF247powerUpEv"]
        pub fn RF24_powerUp(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Write for single NOACK writes. Optionally disables acknowledgements/autoretries for a single write."]
        #[doc = ""]
        #[doc = " @note enableDynamicAck() must be called to enable this feature"]
        #[doc = ""]
        #[doc = " Can be used with enableAckPayload() to request a response"]
        #[doc = " @see enableDynamicAck()"]
        #[doc = " @see setAutoAck()"]
        #[doc = " @see write()"]
        #[doc = ""]
        #[doc = " @param buf Pointer to the data to be sent"]
        #[doc = " @param len Number of bytes to be sent"]
        #[doc = " @param multicast Request ACK (0), NOACK (1)"]
        #[link_name = "\u{1}__ZN4RF245writeEPKvhb"]
        pub fn RF24_write1(
            this: *mut root::RF24,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            multicast: bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " This will not block until the 3 FIFO buffers are filled with data."]
        #[doc = " Once the FIFOs are full, writeFast will simply wait for success or"]
        #[doc = " timeout, and return 1 or 0 respectively. From a user perspective, just"]
        #[doc = " keep trying to send the same data. The library will keep auto retrying"]
        #[doc = " the current payload using the built in functionality."]
        #[doc = " @warning It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto"]
        #[doc = " retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO"]
        #[doc = " to clear by issuing txStandBy() or ensure appropriate time between transmissions."]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " Example (Partial blocking):"]
        #[doc = ""]
        #[doc = "\t\t\tradio.writeFast(&buf,32);  // Writes 1 payload to the buffers"]
        #[doc = "\t\t\ttxStandBy();     \t\t   // Returns 0 if failed. 1 if success. Blocks only until MAX_RT timeout or success. Data flushed on fail."]
        #[doc = ""]
        #[doc = "\t\t\tradio.writeFast(&buf,32);  // Writes 1 payload to the buffers"]
        #[doc = "\t\t\ttxStandBy(1000);\t\t   // Using extended timeouts, returns 1 if success. Retries failed payloads for 1 seconds before returning 0."]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @see txStandBy()"]
        #[doc = " @see write()"]
        #[doc = " @see writeBlocking()"]
        #[doc = ""]
        #[doc = " @param buf Pointer to the data to be sent"]
        #[doc = " @param len Number of bytes to be sent"]
        #[doc = " @return True if the payload was delivered successfully false if not"]
        #[link_name = "\u{1}__ZN4RF249writeFastEPKvh"]
        pub fn RF24_writeFast(
            this: *mut root::RF24,
            buf: *const ::std::os::raw::c_void,
            len: u8,
        ) -> bool;
    }
    extern "C" {
        #[doc = " WriteFast for single NOACK writes. Disables acknowledgements/autoretries for a single write."]
        #[doc = ""]
        #[doc = " @note enableDynamicAck() must be called to enable this feature"]
        #[doc = " @see enableDynamicAck()"]
        #[doc = " @see setAutoAck()"]
        #[doc = ""]
        #[doc = " @param buf Pointer to the data to be sent"]
        #[doc = " @param len Number of bytes to be sent"]
        #[doc = " @param multicast Request ACK (0) or NOACK (1)"]
        #[link_name = "\u{1}__ZN4RF249writeFastEPKvhb"]
        pub fn RF24_writeFast1(
            this: *mut root::RF24,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            multicast: bool,
        ) -> bool;
    }
    extern "C" {
        #[doc = " This function extends the auto-retry mechanism to any specified duration."]
        #[doc = " It will not block until the 3 FIFO buffers are filled with data."]
        #[doc = " If so the library will auto retry until a new payload is written"]
        #[doc = " or the user specified timeout period is reached."]
        #[doc = " @warning It is important to never keep the nRF24L01 in TX mode and FIFO full for more than 4ms at a time. If the auto"]
        #[doc = " retransmit is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO"]
        #[doc = " to clear by issuing txStandBy() or ensure appropriate time between transmissions."]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " Example (Full blocking):"]
        #[doc = ""]
        #[doc = "\t\t\tradio.writeBlocking(&buf,32,1000); //Wait up to 1 second to write 1 payload to the buffers"]
        #[doc = "\t\t\ttxStandBy(1000);     \t\t\t   //Wait up to 1 second for the payload to send. Return 1 if ok, 0 if failed."]
        #[doc = "\t\t\t\t\t  \t\t\t\t   \t\t   //Blocks only until user timeout or success. Data flushed on fail."]
        #[doc = " @endcode"]
        #[doc = " @note If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable millis()."]
        #[doc = " @see txStandBy()"]
        #[doc = " @see write()"]
        #[doc = " @see writeFast()"]
        #[doc = ""]
        #[doc = " @param buf Pointer to the data to be sent"]
        #[doc = " @param len Number of bytes to be sent"]
        #[doc = " @param timeout User defined timeout in milliseconds."]
        #[doc = " @return True if the payload was loaded into the buffer successfully false if not"]
        #[link_name = "\u{1}__ZN4RF2413writeBlockingEPKvhj"]
        pub fn RF24_writeBlocking(
            this: *mut root::RF24,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            timeout: u32,
        ) -> bool;
    }
    extern "C" {
        #[doc = " This function should be called as soon as transmission is finished to"]
        #[doc = " drop the radio back to STANDBY-I mode. If not issued, the radio will"]
        #[doc = " remain in STANDBY-II mode which, per the data sheet, is not a recommended"]
        #[doc = " operating mode."]
        #[doc = ""]
        #[doc = " @note When transmitting data in rapid succession, it is still recommended by"]
        #[doc = " the manufacturer to drop the radio out of TX or STANDBY-II mode if there is"]
        #[doc = " time enough between sends for the FIFOs to empty. This is not required if auto-ack"]
        #[doc = " is enabled."]
        #[doc = ""]
        #[doc = " Relies on built-in auto retry functionality."]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " Example (Partial blocking):"]
        #[doc = ""]
        #[doc = "\t\t\tradio.writeFast(&buf,32);"]
        #[doc = "\t\t\tradio.writeFast(&buf,32);"]
        #[doc = "\t\t\tradio.writeFast(&buf,32);  //Fills the FIFO buffers up"]
        #[doc = "\t\t\tbool ok = txStandBy();     //Returns 0 if failed. 1 if success."]
        #[doc = "\t\t\t\t\t  \t\t\t\t   //Blocks only until MAX_RT timeout or success. Data flushed on fail."]
        #[doc = " @endcode"]
        #[doc = " @see txStandBy(unsigned long timeout)"]
        #[doc = " @return True if transmission is successful"]
        #[doc = ""]
        #[link_name = "\u{1}__ZN4RF249txStandByEv"]
        pub fn RF24_txStandBy(this: *mut root::RF24) -> bool;
    }
    extern "C" {
        #[doc = " This function allows extended blocking and auto-retries per a user defined timeout"]
        #[doc = " @code"]
        #[doc = "\tFully Blocking Example:"]
        #[doc = ""]
        #[doc = "\t\t\tradio.writeFast(&buf,32);"]
        #[doc = "\t\t\tradio.writeFast(&buf,32);"]
        #[doc = "\t\t\tradio.writeFast(&buf,32);   //Fills the FIFO buffers up"]
        #[doc = "\t\t\tbool ok = txStandBy(1000);  //Returns 0 if failed after 1 second of retries. 1 if success."]
        #[doc = "\t\t\t\t\t  \t\t\t\t    //Blocks only until user defined timeout or success. Data flushed on fail."]
        #[doc = " @endcode"]
        #[doc = " @note If used from within an interrupt, the interrupt should be disabled until completion, and sei(); called to enable millis()."]
        #[doc = " @param timeout Number of milliseconds to retry failed payloads"]
        #[doc = " @return True if transmission is successful"]
        #[doc = ""]
        #[link_name = "\u{1}__ZN4RF249txStandByEjb"]
        pub fn RF24_txStandBy1(this: *mut root::RF24, timeout: u32, startTx: bool) -> bool;
    }
    extern "C" {
        #[doc = " Write an ack payload for the specified pipe"]
        #[doc = ""]
        #[doc = " The next time a message is received on @p pipe, the data in @p buf will"]
        #[doc = " be sent back in the acknowledgement."]
        #[doc = " @see enableAckPayload()"]
        #[doc = " @see enableDynamicPayloads()"]
        #[doc = " @warning Only three of these can be pending at any time as there are only 3 FIFO buffers.<br> Dynamic payloads must be enabled."]
        #[doc = " @note Ack payloads are handled automatically by the radio chip when a payload is received. Users should generally"]
        #[doc = " write an ack payload as soon as startListening() is called, so one is available when a regular payload is received."]
        #[doc = " @note Ack payloads are dynamic payloads. This only works on pipes 0&1 by default. Call"]
        #[doc = " enableDynamicPayloads() to enable on all pipes."]
        #[doc = ""]
        #[doc = " @param pipe Which pipe# (typically 1-5) will get this response."]
        #[doc = " @param buf Pointer to data that is sent"]
        #[doc = " @param len Length of the data to send, up to 32 bytes max.  Not affected"]
        #[doc = " by the static payload set by setPayloadSize()."]
        #[link_name = "\u{1}__ZN4RF2415writeAckPayloadEhPKvh"]
        pub fn RF24_writeAckPayload(
            this: *mut root::RF24,
            pipe: u8,
            buf: *const ::std::os::raw::c_void,
            len: u8,
        );
    }
    extern "C" {
        #[doc = " Determine if an ack payload was received in the most recent call to"]
        #[doc = " write(). The regular available() can also be used."]
        #[doc = ""]
        #[doc = " Call read() to retrieve the ack payload."]
        #[doc = ""]
        #[doc = " @return True if an ack payload is available."]
        #[link_name = "\u{1}__ZN4RF2421isAckPayloadAvailableEv"]
        pub fn RF24_isAckPayloadAvailable(this: *mut root::RF24) -> bool;
    }
    extern "C" {
        #[doc = " Call this when you get an interrupt to find out why"]
        #[doc = ""]
        #[doc = " Tells you what caused the interrupt, and clears the state of"]
        #[doc = " interrupts."]
        #[doc = ""]
        #[doc = " @param[out] tx_ok The send was successful (TX_DS)"]
        #[doc = " @param[out] tx_fail The send failed, too many retries (MAX_RT)"]
        #[doc = " @param[out] rx_ready There is a message waiting to be read (RX_DS)"]
        #[link_name = "\u{1}__ZN4RF2412whatHappenedERbS0_S0_"]
        pub fn RF24_whatHappened(
            this: *mut root::RF24,
            tx_ok: *mut bool,
            tx_fail: *mut bool,
            rx_ready: *mut bool,
        );
    }
    extern "C" {
        #[doc = " Non-blocking write to the open writing pipe used for buffered writes"]
        #[doc = ""]
        #[doc = " @note Optimization: This function now leaves the CE pin high, so the radio"]
        #[doc = " will remain in TX or STANDBY-II Mode until a txStandBy() command is issued. Can be used as an alternative to startWrite()"]
        #[doc = " if writing multiple payloads at once."]
        #[doc = " @warning It is important to never keep the nRF24L01 in TX mode with FIFO full for more than 4ms at a time. If the auto"]
        #[doc = " retransmit/autoAck is enabled, the nRF24L01 is never in TX mode long enough to disobey this rule. Allow the FIFO"]
        #[doc = " to clear by issuing txStandBy() or ensure appropriate time between transmissions."]
        #[doc = ""]
        #[doc = " @see write()"]
        #[doc = " @see writeFast()"]
        #[doc = " @see startWrite()"]
        #[doc = " @see writeBlocking()"]
        #[doc = ""]
        #[doc = " For single noAck writes see:"]
        #[doc = " @see enableDynamicAck()"]
        #[doc = " @see setAutoAck()"]
        #[doc = ""]
        #[doc = " @param buf Pointer to the data to be sent"]
        #[doc = " @param len Number of bytes to be sent"]
        #[doc = " @param multicast Request ACK (0) or NOACK (1)"]
        #[doc = " @return True if the payload was delivered successfully false if not"]
        #[link_name = "\u{1}__ZN4RF2414startFastWriteEPKvhbb"]
        pub fn RF24_startFastWrite(
            this: *mut root::RF24,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            multicast: bool,
            startTx: bool,
        );
    }
    extern "C" {
        #[doc = " Non-blocking write to the open writing pipe"]
        #[doc = ""]
        #[doc = " Just like write(), but it returns immediately. To find out what happened"]
        #[doc = " to the send, catch the IRQ and then call whatHappened()."]
        #[doc = ""]
        #[doc = " @see write()"]
        #[doc = " @see writeFast()"]
        #[doc = " @see startFastWrite()"]
        #[doc = " @see whatHappened()"]
        #[doc = ""]
        #[doc = " For single noAck writes see:"]
        #[doc = " @see enableDynamicAck()"]
        #[doc = " @see setAutoAck()"]
        #[doc = ""]
        #[doc = " @param buf Pointer to the data to be sent"]
        #[doc = " @param len Number of bytes to be sent"]
        #[doc = " @param multicast Request ACK (0) or NOACK (1)"]
        #[doc = ""]
        #[link_name = "\u{1}__ZN4RF2410startWriteEPKvhb"]
        pub fn RF24_startWrite(
            this: *mut root::RF24,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            multicast: bool,
        );
    }
    extern "C" {
        #[doc = " This function is mainly used internally to take advantage of the auto payload"]
        #[doc = " re-use functionality of the chip, but can be beneficial to users as well."]
        #[doc = ""]
        #[doc = " The function will instruct the radio to re-use the data in the FIFO buffers,"]
        #[doc = " and instructs the radio to re-send once the timeout limit has been reached."]
        #[doc = " Used by writeFast and writeBlocking to initiate retries when a TX failure"]
        #[doc = " occurs. Retries are automatically initiated except with the standard write()."]
        #[doc = " This way, data is not flushed from the buffer until switching between modes."]
        #[doc = ""]
        #[doc = " @note This is to be used AFTER auto-retry fails if wanting to resend"]
        #[doc = " using the built-in payload reuse features."]
        #[doc = " After issuing reUseTX(), it will keep reending the same payload forever or until"]
        #[doc = " a payload is written to the FIFO, or a flush_tx command is given."]
        #[link_name = "\u{1}__ZN4RF247reUseTXEv"]
        pub fn RF24_reUseTX(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Empty the transmit buffer. This is generally not required in standard operation."]
        #[doc = " May be required in specific cases after stopListening() , if operating at 250KBPS data rate."]
        #[doc = ""]
        #[doc = " @return Current value of status register"]
        #[link_name = "\u{1}__ZN4RF248flush_txEv"]
        pub fn RF24_flush_tx(this: *mut root::RF24) -> u8;
    }
    extern "C" {
        #[doc = " Test whether there was a carrier on the line for the"]
        #[doc = " previous listening period."]
        #[doc = ""]
        #[doc = " Useful to check for interference on the current channel."]
        #[doc = ""]
        #[doc = " @return true if was carrier, false if not"]
        #[link_name = "\u{1}__ZN4RF2411testCarrierEv"]
        pub fn RF24_testCarrier(this: *mut root::RF24) -> bool;
    }
    extern "C" {
        #[doc = " Test whether a signal (carrier or otherwise) greater than"]
        #[doc = " or equal to -64dBm is present on the channel. Valid only"]
        #[doc = " on nRF24L01P (+) hardware. On nRF24L01, use testCarrier()."]
        #[doc = ""]
        #[doc = " Useful to check for interference on the current channel and"]
        #[doc = " channel hopping strategies."]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " bool goodSignal = radio.testRPD();"]
        #[doc = " if(radio.available()){"]
        #[doc = "    Serial.println(goodSignal ? \"Strong signal > 64dBm\" : \"Weak signal < 64dBm\" );"]
        #[doc = "    radio.read(0,0);"]
        #[doc = " }"]
        #[doc = " @endcode"]
        #[doc = " @return true if signal => -64dBm, false if not"]
        #[link_name = "\u{1}__ZN4RF247testRPDEv"]
        pub fn RF24_testRPD(this: *mut root::RF24) -> bool;
    }
    extern "C" {
        #[doc = " Close a pipe after it has been previously opened."]
        #[doc = " Can be safely called without having previously opened a pipe."]
        #[doc = " @param pipe Which pipe # to close, 0-5."]
        #[link_name = "\u{1}__ZN4RF2416closeReadingPipeEh"]
        pub fn RF24_closeReadingPipe(this: *mut root::RF24, pipe: u8);
    }
    extern "C" {
        #[doc = " Set the address width from 3 to 5 bytes (24, 32 or 40 bit)"]
        #[doc = ""]
        #[doc = " @param a_width The address width to use: 3,4 or 5"]
        #[link_name = "\u{1}__ZN4RF2415setAddressWidthEh"]
        pub fn RF24_setAddressWidth(this: *mut root::RF24, a_width: u8);
    }
    extern "C" {
        #[doc = " Set the number and delay of retries upon failed submit"]
        #[doc = ""]
        #[doc = " @param delay How long to wait between each retry, in multiples of 250us,"]
        #[doc = " max is 15.  0 means 250us, 15 means 4000us."]
        #[doc = " @param count How many retries before giving up, max 15"]
        #[link_name = "\u{1}__ZN4RF2410setRetriesEhh"]
        pub fn RF24_setRetries(this: *mut root::RF24, delay: u8, count: u8);
    }
    extern "C" {
        #[doc = " Set RF communication channel"]
        #[doc = ""]
        #[doc = " @param channel Which RF channel to communicate on, 0-125"]
        #[link_name = "\u{1}__ZN4RF2410setChannelEh"]
        pub fn RF24_setChannel(this: *mut root::RF24, channel: u8);
    }
    extern "C" {
        #[doc = " Get RF communication channel"]
        #[doc = ""]
        #[doc = " @return The currently configured RF Channel"]
        #[link_name = "\u{1}__ZN4RF2410getChannelEv"]
        pub fn RF24_getChannel(this: *mut root::RF24) -> u8;
    }
    extern "C" {
        #[doc = " Set Static Payload Size"]
        #[doc = ""]
        #[doc = " This implementation uses a pre-stablished fixed payload size for all"]
        #[doc = " transmissions.  If this method is never called, the driver will always"]
        #[doc = " transmit the maximum payload size (32 bytes), no matter how much"]
        #[doc = " was sent to write()."]
        #[doc = ""]
        #[doc = " @todo Implement variable-sized payloads feature"]
        #[doc = ""]
        #[doc = " @param size The number of bytes in the payload"]
        #[link_name = "\u{1}__ZN4RF2414setPayloadSizeEh"]
        pub fn RF24_setPayloadSize(this: *mut root::RF24, size: u8);
    }
    extern "C" {
        #[doc = " Get Static Payload Size"]
        #[doc = ""]
        #[doc = " @see setPayloadSize()"]
        #[doc = ""]
        #[doc = " @return The number of bytes in the payload"]
        #[link_name = "\u{1}__ZN4RF2414getPayloadSizeEv"]
        pub fn RF24_getPayloadSize(this: *mut root::RF24) -> u8;
    }
    extern "C" {
        #[doc = " Get Dynamic Payload Size"]
        #[doc = ""]
        #[doc = " For dynamic payloads, this pulls the size of the payload off"]
        #[doc = " the chip"]
        #[doc = ""]
        #[doc = " @note Corrupt packets are now detected and flushed per the"]
        #[doc = " manufacturer."]
        #[doc = " @code"]
        #[doc = " if(radio.available()){"]
        #[doc = "   if(radio.getDynamicPayloadSize() < 1){"]
        #[doc = "     // Corrupt payload has been flushed"]
        #[doc = "     return;"]
        #[doc = "   }"]
        #[doc = "   radio.read(&data,sizeof(data));"]
        #[doc = " }"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @return Payload length of last-received dynamic payload"]
        #[link_name = "\u{1}__ZN4RF2421getDynamicPayloadSizeEv"]
        pub fn RF24_getDynamicPayloadSize(this: *mut root::RF24) -> u8;
    }
    extern "C" {
        #[doc = " Enable custom payloads on the acknowledge packets"]
        #[doc = ""]
        #[doc = " Ack payloads are a handy way to return data back to senders without"]
        #[doc = " manually changing the radio modes on both units."]
        #[doc = ""]
        #[doc = " @note Ack payloads are dynamic payloads. This only works on pipes 0&1 by default. Call"]
        #[doc = " enableDynamicPayloads() to enable on all pipes."]
        #[link_name = "\u{1}__ZN4RF2416enableAckPayloadEv"]
        pub fn RF24_enableAckPayload(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Enable dynamically-sized payloads"]
        #[doc = ""]
        #[doc = " This way you don't always have to send large packets just to send them"]
        #[doc = " once in a while.  This enables dynamic payloads on ALL pipes."]
        #[doc = ""]
        #[link_name = "\u{1}__ZN4RF2421enableDynamicPayloadsEv"]
        pub fn RF24_enableDynamicPayloads(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Disable dynamically-sized payloads"]
        #[doc = ""]
        #[doc = " This disables dynamic payloads on ALL pipes. Since Ack Payloads"]
        #[doc = " requires Dynamic Payloads, Ack Payloads are also disabled."]
        #[doc = " If dynamic payloads are later re-enabled and ack payloads are desired"]
        #[doc = " then enableAckPayload() must be called again as well."]
        #[doc = ""]
        #[link_name = "\u{1}__ZN4RF2422disableDynamicPayloadsEv"]
        pub fn RF24_disableDynamicPayloads(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Enable dynamic ACKs (single write multicast or unicast) for chosen messages"]
        #[doc = ""]
        #[doc = " @note To enable full multicast or per-pipe multicast, use setAutoAck()"]
        #[doc = ""]
        #[doc = " @warning This MUST be called prior to attempting single write NOACK calls"]
        #[doc = " @code"]
        #[doc = " radio.enableDynamicAck();"]
        #[doc = " radio.write(&data,32,1);  // Sends a payload with no acknowledgement requested"]
        #[doc = " radio.write(&data,32,0);  // Sends a payload using auto-retry/autoACK"]
        #[doc = " @endcode"]
        #[link_name = "\u{1}__ZN4RF2416enableDynamicAckEv"]
        pub fn RF24_enableDynamicAck(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " Determine whether the hardware is an nRF24L01+ or not."]
        #[doc = ""]
        #[doc = " @return true if the hardware is nRF24L01+ (or compatible) and false"]
        #[doc = " if its not."]
        #[link_name = "\u{1}__ZN4RF2410isPVariantEv"]
        pub fn RF24_isPVariant(this: *mut root::RF24) -> bool;
    }
    extern "C" {
        #[doc = " Enable or disable auto-acknowlede packets"]
        #[doc = ""]
        #[doc = " This is enabled by default, so it's only needed if you want to turn"]
        #[doc = " it off for some reason."]
        #[doc = ""]
        #[doc = " @param enable Whether to enable (true) or disable (false) auto-acks"]
        #[link_name = "\u{1}__ZN4RF2410setAutoAckEb"]
        pub fn RF24_setAutoAck(this: *mut root::RF24, enable: bool);
    }
    extern "C" {
        #[doc = " Enable or disable auto-acknowlede packets on a per pipeline basis."]
        #[doc = ""]
        #[doc = " AA is enabled by default, so it's only needed if you want to turn"]
        #[doc = " it off/on for some reason on a per pipeline basis."]
        #[doc = ""]
        #[doc = " @param pipe Which pipeline to modify"]
        #[doc = " @param enable Whether to enable (true) or disable (false) auto-acks"]
        #[link_name = "\u{1}__ZN4RF2410setAutoAckEhb"]
        pub fn RF24_setAutoAck1(this: *mut root::RF24, pipe: u8, enable: bool);
    }
    extern "C" {
        #[doc = " Set Power Amplifier (PA) level to one of four levels:"]
        #[doc = " RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH and RF24_PA_MAX"]
        #[doc = ""]
        #[doc = " The power levels correspond to the following output levels respectively:"]
        #[doc = " NRF24L01: -18dBm, -12dBm,-6dBM, and 0dBm"]
        #[doc = ""]
        #[doc = " SI24R1: -6dBm, 0dBm, 3dBM, and 7dBm."]
        #[doc = ""]
        #[doc = " @param level Desired PA level."]
        #[link_name = "\u{1}__ZN4RF2410setPALevelEh"]
        pub fn RF24_setPALevel(this: *mut root::RF24, level: u8);
    }
    extern "C" {
        #[doc = " Fetches the current PA level."]
        #[doc = ""]
        #[doc = " NRF24L01: -18dBm, -12dBm, -6dBm and 0dBm"]
        #[doc = " SI24R1:   -6dBm, 0dBm, 3dBm, 7dBm"]
        #[doc = ""]
        #[doc = " @return Returns values 0 to 3 representing the PA Level."]
        #[link_name = "\u{1}__ZN4RF2410getPALevelEv"]
        pub fn RF24_getPALevel(this: *mut root::RF24) -> u8;
    }
    extern "C" {
        #[doc = " Set the transmission data rate"]
        #[doc = ""]
        #[doc = " @warning setting RF24_250KBPS will fail for non-plus units"]
        #[doc = ""]
        #[doc = " @param speed RF24_250KBPS for 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS for 2Mbps"]
        #[doc = " @return true if the change was successful"]
        #[link_name = "\u{1}__ZN4RF2411setDataRateE15rf24_datarate_e"]
        pub fn RF24_setDataRate(this: *mut root::RF24, speed: root::rf24_datarate_e) -> bool;
    }
    extern "C" {
        #[doc = " Fetches the transmission data rate"]
        #[doc = ""]
        #[doc = " @return Returns the hardware's currently configured datarate. The value"]
        #[doc = " is one of 250kbs, RF24_1MBPS for 1Mbps, or RF24_2MBPS, as defined in the"]
        #[doc = " rf24_datarate_e enum."]
        #[link_name = "\u{1}__ZN4RF2411getDataRateEv"]
        pub fn RF24_getDataRate(this: *mut root::RF24) -> root::rf24_datarate_e;
    }
    extern "C" {
        #[doc = " Set the CRC length"]
        #[doc = " <br>CRC checking cannot be disabled if auto-ack is enabled"]
        #[doc = " @param length RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit"]
        #[link_name = "\u{1}__ZN4RF2412setCRCLengthE16rf24_crclength_e"]
        pub fn RF24_setCRCLength(this: *mut root::RF24, length: root::rf24_crclength_e);
    }
    extern "C" {
        #[doc = " Get the CRC length"]
        #[doc = " <br>CRC checking cannot be disabled if auto-ack is enabled"]
        #[doc = " @return RF24_CRC_DISABLED if disabled or RF24_CRC_8 for 8-bit or RF24_CRC_16 for 16-bit"]
        #[link_name = "\u{1}__ZN4RF2412getCRCLengthEv"]
        pub fn RF24_getCRCLength(this: *mut root::RF24) -> root::rf24_crclength_e;
    }
    extern "C" {
        #[doc = " Disable CRC validation"]
        #[doc = ""]
        #[doc = " @warning CRC cannot be disabled if auto-ack/ESB is enabled."]
        #[link_name = "\u{1}__ZN4RF2410disableCRCEv"]
        pub fn RF24_disableCRC(this: *mut root::RF24);
    }
    extern "C" {
        #[doc = " The radio will generate interrupt signals when a transmission is complete,"]
        #[doc = " a transmission fails, or a payload is received. This allows users to mask"]
        #[doc = " those interrupts to prevent them from generating a signal on the interrupt"]
        #[doc = " pin. Interrupts are enabled on the radio chip by default."]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = " \tMask all interrupts except the receive interrupt:"]
        #[doc = ""]
        #[doc = "\t\tradio.maskIRQ(1,1,0);"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @param tx_ok  Mask transmission complete interrupts"]
        #[doc = " @param tx_fail  Mask transmit failure interrupts"]
        #[doc = " @param rx_ready Mask payload received interrupts"]
        #[link_name = "\u{1}__ZN4RF247maskIRQEbbb"]
        pub fn RF24_maskIRQ(this: *mut root::RF24, tx_ok: bool, tx_fail: bool, rx_ready: bool);
    }
    extern "C" {
        #[doc = " Open a pipe for reading"]
        #[doc = " @note For compatibility with old code only, see new function"]
        #[doc = ""]
        #[doc = " @warning Pipes 1-5 should share the first 32 bits."]
        #[doc = " Only the least significant byte should be unique, e.g."]
        #[doc = " @code"]
        #[doc = "   openReadingPipe(1,0xF0F0F0F0AA);"]
        #[doc = "   openReadingPipe(2,0xF0F0F0F066);"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @warning Pipe 0 is also used by the writing pipe.  So if you open"]
        #[doc = " pipe 0 for reading, and then startListening(), it will overwrite the"]
        #[doc = " writing pipe.  Ergo, do an openWritingPipe() again before write()."]
        #[doc = ""]
        #[doc = " @param number Which pipe# to open, 0-5."]
        #[doc = " @param address The 40-bit address of the pipe to open."]
        #[link_name = "\u{1}__ZN4RF2415openReadingPipeEhy"]
        pub fn RF24_openReadingPipe1(this: *mut root::RF24, number: u8, address: u64);
    }
    extern "C" {
        #[doc = " Open a pipe for writing"]
        #[doc = " @note For compatibility with old code only, see new function"]
        #[doc = ""]
        #[doc = " Addresses are 40-bit hex values, e.g.:"]
        #[doc = ""]
        #[doc = " @code"]
        #[doc = "   openWritingPipe(0xF0F0F0F0F0);"]
        #[doc = " @endcode"]
        #[doc = ""]
        #[doc = " @param address The 40-bit address of the pipe to open."]
        #[link_name = "\u{1}__ZN4RF2415openWritingPipeEy"]
        pub fn RF24_openWritingPipe1(this: *mut root::RF24, address: u64);
    }
    extern "C" {
        #[doc = " Empty the receive buffer"]
        #[doc = ""]
        #[doc = " @return Current value of status register"]
        #[link_name = "\u{1}__ZN4RF248flush_rxEv"]
        pub fn RF24_flush_rx(this: *mut root::RF24) -> u8;
    }
    extern "C" {
        #[doc = " Arduino Constructor"]
        #[doc = ""]
        #[doc = " Creates a new instance of this driver.  Before using, you create an instance"]
        #[doc = " and send in the unique pins that this chip is connected to."]
        #[doc = ""]
        #[doc = " @param _cepin The pin attached to Chip Enable on the RF module"]
        #[doc = " @param _cspin The pin attached to Chip Select"]
        #[link_name = "\u{1}__ZN4RF24C1Ett"]
        pub fn RF24_RF24(this: *mut root::RF24, _cepin: u16, _cspin: u16);
    }
    extern "C" {
        #[doc = " Optional Linux Constructor"]
        #[doc = ""]
        #[doc = " Creates a new instance of this driver.  Before using, you create an instance"]
        #[doc = " and send in the unique pins that this chip is connected to."]
        #[doc = ""]
        #[doc = " @param _cepin The pin attached to Chip Enable on the RF module"]
        #[doc = " @param _cspin The pin attached to Chip Select"]
        #[doc = " @param spispeed For RPi, the SPI speed in MHZ ie: BCM2835_SPI_SPEED_8MHZ"]
        #[link_name = "\u{1}__ZN4RF24C1Ettj"]
        pub fn RF24_RF241(this: *mut root::RF24, _cepin: u16, _cspin: u16, spispeed: u32);
    }
    impl RF24 {
        #[inline]
        pub unsafe fn begin(&mut self) -> bool {
            RF24_begin(self)
        }
        #[inline]
        pub unsafe fn isChipConnected(&mut self) -> bool {
            RF24_isChipConnected(self)
        }
        #[inline]
        pub unsafe fn startListening(&mut self) {
            RF24_startListening(self)
        }
        #[inline]
        pub unsafe fn stopListening(&mut self) {
            RF24_stopListening(self)
        }
        #[inline]
        pub unsafe fn available(&mut self) -> bool {
            RF24_available(self)
        }
        #[inline]
        pub unsafe fn read(&mut self, buf: *mut ::std::os::raw::c_void, len: u8) {
            RF24_read(self, buf, len)
        }
        #[inline]
        pub unsafe fn write(&mut self, buf: *const ::std::os::raw::c_void, len: u8) -> bool {
            RF24_write(self, buf, len)
        }
        #[inline]
        pub unsafe fn openWritingPipe(&mut self, address: *const u8) {
            RF24_openWritingPipe(self, address)
        }
        #[inline]
        pub unsafe fn openReadingPipe(&mut self, number: u8, address: *const u8) {
            RF24_openReadingPipe(self, number, address)
        }
        #[inline]
        pub unsafe fn printDetails(&mut self) {
            RF24_printDetails(self)
        }
        #[inline]
        pub unsafe fn available1(&mut self, pipe_num: *mut u8) -> bool {
            RF24_available1(self, pipe_num)
        }
        #[inline]
        pub unsafe fn rxFifoFull(&mut self) -> bool {
            RF24_rxFifoFull(self)
        }
        #[inline]
        pub unsafe fn powerDown(&mut self) {
            RF24_powerDown(self)
        }
        #[inline]
        pub unsafe fn powerUp(&mut self) {
            RF24_powerUp(self)
        }
        #[inline]
        pub unsafe fn write1(
            &mut self,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            multicast: bool,
        ) -> bool {
            RF24_write1(self, buf, len, multicast)
        }
        #[inline]
        pub unsafe fn writeFast(&mut self, buf: *const ::std::os::raw::c_void, len: u8) -> bool {
            RF24_writeFast(self, buf, len)
        }
        #[inline]
        pub unsafe fn writeFast1(
            &mut self,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            multicast: bool,
        ) -> bool {
            RF24_writeFast1(self, buf, len, multicast)
        }
        #[inline]
        pub unsafe fn writeBlocking(
            &mut self,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            timeout: u32,
        ) -> bool {
            RF24_writeBlocking(self, buf, len, timeout)
        }
        #[inline]
        pub unsafe fn txStandBy(&mut self) -> bool {
            RF24_txStandBy(self)
        }
        #[inline]
        pub unsafe fn txStandBy1(&mut self, timeout: u32, startTx: bool) -> bool {
            RF24_txStandBy1(self, timeout, startTx)
        }
        #[inline]
        pub unsafe fn writeAckPayload(
            &mut self,
            pipe: u8,
            buf: *const ::std::os::raw::c_void,
            len: u8,
        ) {
            RF24_writeAckPayload(self, pipe, buf, len)
        }
        #[inline]
        pub unsafe fn isAckPayloadAvailable(&mut self) -> bool {
            RF24_isAckPayloadAvailable(self)
        }
        #[inline]
        pub unsafe fn whatHappened(
            &mut self,
            tx_ok: *mut bool,
            tx_fail: *mut bool,
            rx_ready: *mut bool,
        ) {
            RF24_whatHappened(self, tx_ok, tx_fail, rx_ready)
        }
        #[inline]
        pub unsafe fn startFastWrite(
            &mut self,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            multicast: bool,
            startTx: bool,
        ) {
            RF24_startFastWrite(self, buf, len, multicast, startTx)
        }
        #[inline]
        pub unsafe fn startWrite(
            &mut self,
            buf: *const ::std::os::raw::c_void,
            len: u8,
            multicast: bool,
        ) {
            RF24_startWrite(self, buf, len, multicast)
        }
        #[inline]
        pub unsafe fn reUseTX(&mut self) {
            RF24_reUseTX(self)
        }
        #[inline]
        pub unsafe fn flush_tx(&mut self) -> u8 {
            RF24_flush_tx(self)
        }
        #[inline]
        pub unsafe fn testCarrier(&mut self) -> bool {
            RF24_testCarrier(self)
        }
        #[inline]
        pub unsafe fn testRPD(&mut self) -> bool {
            RF24_testRPD(self)
        }
        #[inline]
        pub unsafe fn closeReadingPipe(&mut self, pipe: u8) {
            RF24_closeReadingPipe(self, pipe)
        }
        #[inline]
        pub unsafe fn setAddressWidth(&mut self, a_width: u8) {
            RF24_setAddressWidth(self, a_width)
        }
        #[inline]
        pub unsafe fn setRetries(&mut self, delay: u8, count: u8) {
            RF24_setRetries(self, delay, count)
        }
        #[inline]
        pub unsafe fn setChannel(&mut self, channel: u8) {
            RF24_setChannel(self, channel)
        }
        #[inline]
        pub unsafe fn getChannel(&mut self) -> u8 {
            RF24_getChannel(self)
        }
        #[inline]
        pub unsafe fn setPayloadSize(&mut self, size: u8) {
            RF24_setPayloadSize(self, size)
        }
        #[inline]
        pub unsafe fn getPayloadSize(&mut self) -> u8 {
            RF24_getPayloadSize(self)
        }
        #[inline]
        pub unsafe fn getDynamicPayloadSize(&mut self) -> u8 {
            RF24_getDynamicPayloadSize(self)
        }
        #[inline]
        pub unsafe fn enableAckPayload(&mut self) {
            RF24_enableAckPayload(self)
        }
        #[inline]
        pub unsafe fn enableDynamicPayloads(&mut self) {
            RF24_enableDynamicPayloads(self)
        }
        #[inline]
        pub unsafe fn disableDynamicPayloads(&mut self) {
            RF24_disableDynamicPayloads(self)
        }
        #[inline]
        pub unsafe fn enableDynamicAck(&mut self) {
            RF24_enableDynamicAck(self)
        }
        #[inline]
        pub unsafe fn isPVariant(&mut self) -> bool {
            RF24_isPVariant(self)
        }
        #[inline]
        pub unsafe fn setAutoAck(&mut self, enable: bool) {
            RF24_setAutoAck(self, enable)
        }
        #[inline]
        pub unsafe fn setAutoAck1(&mut self, pipe: u8, enable: bool) {
            RF24_setAutoAck1(self, pipe, enable)
        }
        #[inline]
        pub unsafe fn setPALevel(&mut self, level: u8) {
            RF24_setPALevel(self, level)
        }
        #[inline]
        pub unsafe fn getPALevel(&mut self) -> u8 {
            RF24_getPALevel(self)
        }
        #[inline]
        pub unsafe fn setDataRate(&mut self, speed: root::rf24_datarate_e) -> bool {
            RF24_setDataRate(self, speed)
        }
        #[inline]
        pub unsafe fn getDataRate(&mut self) -> root::rf24_datarate_e {
            RF24_getDataRate(self)
        }
        #[inline]
        pub unsafe fn setCRCLength(&mut self, length: root::rf24_crclength_e) {
            RF24_setCRCLength(self, length)
        }
        #[inline]
        pub unsafe fn getCRCLength(&mut self) -> root::rf24_crclength_e {
            RF24_getCRCLength(self)
        }
        #[inline]
        pub unsafe fn disableCRC(&mut self) {
            RF24_disableCRC(self)
        }
        #[inline]
        pub unsafe fn maskIRQ(&mut self, tx_ok: bool, tx_fail: bool, rx_ready: bool) {
            RF24_maskIRQ(self, tx_ok, tx_fail, rx_ready)
        }
        #[inline]
        pub unsafe fn openReadingPipe1(&mut self, number: u8, address: u64) {
            RF24_openReadingPipe1(self, number, address)
        }
        #[inline]
        pub unsafe fn openWritingPipe1(&mut self, address: u64) {
            RF24_openWritingPipe1(self, address)
        }
        #[inline]
        pub unsafe fn flush_rx(&mut self) -> u8 {
            RF24_flush_rx(self)
        }
        #[inline]
        pub unsafe fn new(_cepin: u16, _cspin: u16) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            RF24_RF24(&mut __bindgen_tmp, _cepin, _cspin);
            __bindgen_tmp
        }
        #[inline]
        pub unsafe fn new1(_cepin: u16, _cspin: u16, spispeed: u32) -> Self {
            let mut __bindgen_tmp = ::std::mem::uninitialized();
            RF24_RF241(&mut __bindgen_tmp, _cepin, _cspin, spispeed);
            __bindgen_tmp
        }
    }
}
